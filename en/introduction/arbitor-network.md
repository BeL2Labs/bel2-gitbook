# Arbitor Network

BeL2可以为BTC交易生成零知识证明，既可以在合约里验证它的真伪，获知发生了某个交易，也可以通过证明了解交易的具体内容。这就让我们可以实现一个“监督”智能合约。如果某个我们关注的BTC地址发生了关联交易，通过为它生成一个ZKP并传递到合约即可让合约感知到它。这时合约就可以根据预定的业务逻辑和协议对这个交易进行判断，符合预期或者超出预期。

众所周知，在不扩展BTC的前提下，目前还没有好的办法实现完全去中心的方式托管BTC。虽然BitVM提出了一个非常有创意的解决方案，但距离可用还有很远一段路。如何让BTC变得可以被智能托管，用于借贷、稳定币和跨链桥等场景，这是社区一直期待和寻找的。

所以，多签或者原理上类似多签的方式是目前被广泛采用的一种BTC托管方案。可以把它当作一种“半信任”的解决方案，虽然引入了托管人，但通过分散权力、治理和监督等机制，让作恶的成本更高了，从而在一定程度上保障了安全。

但由于资金被集中托管，运转流程过长，不够透明等等原因，让这种托管方案很难赢得大多数BTC Holder的信任。而且一旦达到一定人数的托管人作恶，就可能造成损失。

为了改进多签的方案，也有一些项目引入质押，让托管人必须质押资产，甚至是项目方代币。包括一些基于BitVM的项目也是如此，通过罚没作恶者的BTC来约束托管人。这里的新问题是，如何挑战证明作恶？如何惩罚作恶者？如何补偿受损失的用户？这一切必须简单、快速、高效，而不应该是一个漫长而又不明确的过程。

BeL2可以改进对托管人的监督问题，通过创新的零知识证明和智能合约可以监督托管人的行为，并要求托管人在合约中质押资产担保其行为。如果托管人有作恶行为，受害者或者任何人都可以通过将作恶交易/签名生成ZKP提交到合约对其发起挑战，合约可以立即对其行为进行判断，如果挑战成功就可以对作恶的托管人进行惩罚，并将其资产补偿给受害者，以及奖励挑战者。

同时，BeL2支持托管人使用Restaking资产。这意味着托管人不必损失原生资产的流动性和潜在收益，让一份已经失去流动性的资产再次发挥作用。它的作用不是用于被其他人借走，而是用于对自身行为的担保，这就只需要质押者提供的是有价值的资产即可，而不必是高流动性的资产。

因此，通过BeL2+Restaking的组合，可以更好地降低由于引入托管人管理BTC所带来的潜在风险。

在实际项目案例中，为了进一步降低托管人的风险，往往会在以下三个方面进行改进

1. 增加托管人的质押、监督和惩罚机制，制衡他的权力。即使作恶，也会让其付出代价，让受害者得到补偿。
2. 减少托管人的权限，使其无法单独、随意支配资产，只能对利益相关方提出的支配资产的请求进行确认，辅助其完成BTC的提取。
3. 减少托管人与利益相关方的交互，从信息渠道上尽量隔离两者使其难以共谋。

基于BeL2的监督机制可以快速、低成本地实现第一点。dApp在设计协议时，应遵循第二点设计原则，让托管人不能全权处置资产，而是一个“裁判员”，只对利益相关者（终端用户）的请求进行支持或者反对。尽量少使用“裁判员”，而更多是在利益相关者之间博弈，只有出现争议时，再引入“裁判员”帮助协议执行约定的操作。这样，“裁判员”的主要作用是让dApp的协议可以被“强制执行”，不会由于交易双方的争议或者不配合而导致交易被阻断。同时dApp的协议可以设计惩罚，当“裁判员”介入以后，要对不配合的一方进行一定程度的惩罚，从而威慑交易参与者，使其积极参与交易。

当“裁判员”只是作为一种威慑存在时，这样既减少了“裁判员”参与的机会，降低了作恶风险，同时也降低了dApp的运行成本。

在一个生态系统里可能存在多个dApp都需要“裁判员”帮助其执行协议，那么就可以建议这样一个公共的Arbitor网络来帮助生态里的dApp。这些Arbitor是“职业裁判员”，他们只是接收dApp的签名请求，通过签名BTC交易使的dApp中的交易可以被强制执行。

BeL2的Arbitor网络包括三部分组成：Arbitor合约，Arbitor服务，交易证明服务网络

* Arbitor合约
  * Arbitor注册
  * 质押资产
  * Arbitor退出
  * 提交作恶证明挑战Arbitor，以及惩罚和获得补偿
  * 注册dApp
  * 注册需要被监督的交易
  * 请求签名
  * 提交签名
* Arbitor服务
  * 监听Arbitor合约中的签名请求，并进行签名
  * 提交签名
* 交易证明服务网络
  * 为挑战者提供的BTC交易生成零知识证明

让我们以一个BTC借贷为例来介绍BeL2的Arbitor网络。

假设BTC的持有者Alice想要通过质押1个BTC来获得Bob提供的30K USDC的贷款。那么这个BTC Loan dApp的工作流程如下

1. Bob创建一个提供贷款的订单，也就是创建一个订单合约，在其中设置了他预期的最大借款时间，借款数量，利息，Bob的BTC收款地址等等信息，并将30K USDC存入其中。
2. Alice看到Bob的订单以后，认为其满足她的需求，所以就take了Bob的订单，并提交了她的BTC收款地址等信息。
3. BTC Loan dApp根据双方的地址和订单中的信息，为双方生成一个BTC锁定脚本和脚本地址，通过这个脚本锁定Alice的质押，如果Alice正常还款，她可以从脚本中解锁被质押的BTC。如果Alice没有及时还款，Bob将可以解锁被质押的BTC作为补偿。
4. 在生成锁定脚本的同时，BTC Loan dApp也向BeL2的Arbitor合约注册了这个交易的信息，使其可以监督这个交易的执行。
5. Alice将1个BTC发送到订单合约提供的锁定脚本的地址。
6. Bob确认BTC已经被锁定。（如果Bob不确认，Alice可以通过BeL2的ZKP服务生成锁定交易的证明提交到订单合约，代替Bob进行确认）
7. Alice可以从订单合约中借走30K USDC。

BTC Loan dApp的设计遵循前面提到的原则：减少托管人的权限，使其无法单独、随意支配资产，只能对利益相关方提出的支配资产的请求进行确认，辅助其完成BTC的提取。

在这个借款交易中，Alice和Bob是利益相关方，BeL2的Arbitor是监督者，所以，BTC Loan dApp的锁定脚本被设计了三种解锁方式

1. Alice和Bob共同签名解锁BTC
2. 借款到期以后，Bob可以单独签名解锁BTC
3. Alice和Arbitor共同签名解锁BTC

第一种解锁方式是在Alice正常还款以后，Bob配合Alice共同完成了解锁BTC的操作，这是一种互相配合的结果，是我们预期的大多数情况。

第二种解锁方式是在Alice一直不归还借款，直到借款最后到期时间以后，Bob可以解锁BTC作为补偿。

第三种解锁方式是在Alice按时归还借款以后，如果Bob不配合签名解锁BTC的时候，由Arbitor协助签名解锁BTC。这种情况下要对Bob进行惩罚，避免其心存侥幸想要恶意占有Alice的BTC。

Alice和Bob是这个借款交易博弈的两个相关者。如果Alice违约，在超时以后，Bob可以拿走BTC作为补偿。如果Bob违约，不配合退还BTC，那么Alice可以通过BTC Loan dApp发起仲裁请求，将解锁BTC的交易提交到Arbitor合约，Arbitor网络上的Arbitor们会对交易进行签名并广播，从而强制解锁BTC退回给Alice。

如果Arbitor与Alice合谋作恶，Alice并没有还款，Arbitor却还是私下里提供签名（正常来说，BTC Loan dApp应该可以判断Alice是否还款，在没有还款的情况下dApp不会允许向Arbitor合约发起仲裁请求）解锁了BTC。Bob或者其他监督者发现了这笔解锁交易，他们可以为这笔不正常的解锁交易生成零知识证明，并提交到Arbitor合约中对签名的Arbitor发起挑战，被验证以后，Arbitor将被惩罚，Bob可以从Arbitor合约获得补偿。

从这个BTC借贷的例子里，我们可以看到BeL2的Arbitor不是交易的参与者，与交易双方没有利益冲突，只是作为一个利益无关的第三方针对仲裁请求进行签名，他不需要关心交易的内容，不需要关心双方谁对谁错，只要dApp的协议请求签名，他就完成签名。它只是帮助协议执行“BTC签名”操作。补充智能合约无法直接操作BTC这个能力。

并且，如果第三方dApp的设计合理的话，因为Arbitor的存在，可以威慑交易参与者必须遵守协议，那么在大多数情况下，可能都不需要Arbitor参与即可让Alice和Bob顺利完成交易。
